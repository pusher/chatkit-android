<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>EmptyFunctionBlock:CursorService.kt$CursorService${}</ID>
    <ID>EmptyFunctionBlock:MessageService.kt$MessageService${}</ID>
    <ID>EmptyFunctionBlock:RoomService.kt$RoomService${}</ID>
    <ID>EmptyFunctionBlock:UserService.kt$UserService${}</ID>
    <ID>LongParameterList:LoggingSubscription.kt$( path: String, client: PlatformClient, listeners: SubscriptionListeners&lt;A&gt;, messageParser: DataParser&lt;A&gt;, logger: Logger, description: String )</ID>
    <ID>LongParameterList:RoomService.kt$RoomService$( id: String?, creatorId: String, name: String, pushNotificationTitleOverride: String?, isPrivate: Boolean, // customData: CustomData?, userIds: List&lt;String&gt; )</ID>
    <ID>MagicNumber:ChatkitTokenProvider.kt$ChatkitTokenProvider$200</ID>
    <ID>MagicNumber:ChatkitTokenProvider.kt$ChatkitTokenProvider$299</ID>
    <ID>MagicNumber:ChatkitTokenProvider.kt$Clock$1000</ID>
    <ID>MagicNumber:FutureValue.kt$FutureValue$10</ID>
    <ID>MagicNumber:RoomService.kt$RoomService$1_500</ID>
    <ID>MaxLineLength:FilesService.kt$FilesService$"/rooms/${URLEncoder.encode(roomId, "UTF-8")}/users/${URLEncoder.encode(userId, "UTF-8")}/files/${URLEncoder.encode(attachment.name, "UTF-8")}"</ID>
    <ID>MaxLineLength:RoomService.kt$RoomService$client.doPost&lt;Unit?&gt;("/users/${URLEncoder.encode(userId, "UTF-8")}/rooms/${URLEncoder.encode(roomId, "UTF-8")}/leave")</ID>
    <ID>MaxLineLength:RoomService.kt$RoomService${ // Access synchronised on itself private val openSubscriptions = HashMap&lt;String, Subscription&gt;() // private val roomConsumers = ConcurrentHashMap&lt;String, RoomConsumer&gt;() // val roomStore = RoomStore() // private val joinedRoomApiMapper = JoinedRoomApiMapper() // private val notJoinedRoomApiMapper = NotJoinedRoomApiMapper() @Suppress("UNUSED_PARAMETER") fun populateInitial(event: UserSubscriptionEvent.InitialState) { // roomStore.initialiseContents(event.rooms, event.memberships, event.readStates) } @Suppress("UNUSED_PARAMETER") fun getJoinedRoom(id: String) {} // : Result&lt;Room, Error&gt; = // roomStore[id].orElse { Errors.other("Room not found locally") } fun fetchJoinableRooms(userId: String) {} // : Result&lt;List&lt;Room&gt;, Error&gt; = // client.doGet&lt;JoinableRoomsResponse&gt;( // "/users/${URLEncoder.encode(userId, "UTF-8")}/joinable_rooms" // ).map(notJoinedRoomApiMapper::toRooms) fun createRoom( id: String?, creatorId: String, name: String, pushNotificationTitleOverride: String?, isPrivate: Boolean, // customData: CustomData?, userIds: List&lt;String&gt; ) {} // : Result&lt;Room, Error&gt; = // CreateRoomRequest( // id = id, // name = name, // pushNotificationTitleOverride = pushNotificationTitleOverride, // private = isPrivate, // createdById = creatorId, // customData = mapOf&lt;String, Any&gt;(), // userIds = userIds // ).toJson() // .flatMap { body -&gt; client.doPost&lt;CreateRoomResponse&gt;("/rooms", body) } // .map { response -&gt; // roomStore.add(response) // userService.populateUserStore(response.membership.userIds.toSet()) // joinedRoomApiMapper.toRoom(response) // } fun deleteRoom(roomId: String): Result&lt;String, Error&gt; = legacyV2client.doDelete&lt;Unit?&gt;("/rooms/${URLEncoder.encode(roomId, "UTF-8")}") .map { // roomStore.remove(roomId) roomId } fun leaveRoom(userId: String, roomId: String): Result&lt;String, Error&gt; = client.doPost&lt;Unit?&gt;("/users/${URLEncoder.encode(userId, "UTF-8")}/rooms/${URLEncoder.encode(roomId, "UTF-8")}/leave") .map { // roomStore.remove(roomId) roomId } fun joinRoom(userId: String, roomId: String) {} // : Result&lt;Room, Error&gt; = // client.doPost&lt;JoinRoomResponse&gt;("/users/${URLEncoder.encode(userId, "UTF-8")}/rooms/${URLEncoder.encode(roomId, "UTF-8")}/join") // .map { response -&gt; // // roomStore.add(response) // userService.populateUserStore(response.membership.userIds.toSet()) // joinedRoomApiMapper.toRoom(response) // } fun updateRoom( roomId: String, name: String? = null, pushNotificationTitleOverride: RoomPushNotificationTitle? = null, isPrivate: Boolean? = null, customData: Map&lt;String, Any&gt;? = null ): Result&lt;Unit, Error&gt; { val request: Any = if (pushNotificationTitleOverride == null) { UpdateRoomRequest(name, isPrivate) } else { when (pushNotificationTitleOverride) { is RoomPushNotificationTitle.NoOverride -&gt; UpdateRoomRequestWithPushNotificationTitleOverride(name, null, isPrivate) is RoomPushNotificationTitle.Override -&gt; UpdateRoomRequestWithPushNotificationTitleOverride(name, pushNotificationTitleOverride.title, isPrivate) } } return request .toJson() .flatMap { body -&gt; client.doPut&lt;Unit&gt;("/rooms/${URLEncoder.encode(roomId, "UTF-8")}", body) } } fun isSubscribedTo(roomId: String) = synchronized(openSubscriptions) { openSubscriptions[roomId] != null } fun subscribeToRoom( roomId: String, // unsafeConsumer: RoomConsumer, messageLimit: Int ) {} // : Subscription = // subscribeToRoom(roomId, messageLimit, legacyV2client, RoomSubscriptionEventParserV2) fun subscribeToRoomMultipart( roomId: String, // unsafeConsumer: RoomConsumer, messageLimit: Int ) {} // : Subscription = // subscribeToRoom(roomId, messageLimit, client, RoomSubscriptionEventParserV3) private fun subscribeToRoom( roomId: String, // unsafeConsumer: RoomConsumer, messageLimit: Int, client: PlatformClient, parser: DataParser&lt;RoomSubscriptionEvent&gt; ) { // This consumer is made safe by the layer providing it // val globalConsumer = makeGlobalConsumer(roomId) // val consumer: RoomConsumer = { event -&gt; makeSafe(logger) { unsafeConsumer(event) } } // // val buffer = ArrayList&lt;RoomEvent&gt;() // var ready = false // val emit = { event: RoomEvent -&gt; // synchronized(buffer) { // if (ready) { // consumer(event) // globalConsumer(event) // } else { // buffer.add(event) // } // } // Unit // } // val sub = RoomSubscriptionGroup( // messageLimit = messageLimit, // roomId = roomId, // cursorService = cursorsService, // roomConsumer = { emit(enrichEvent(it, emit)) }, // cursorConsumer = { emit(translateCursorEvent(it)) }, // client = client, // messageParser = parser, // logger = logger // ) // synchronized(openSubscriptions) { // openSubscriptions[roomId]?.unsubscribe() // openSubscriptions[roomId] = sub // roomConsumers[roomId] = consumer // } // val proxiedSub = unsubscribeProxy(sub) { // synchronized(openSubscriptions) { // if (openSubscriptions[roomId] == sub) { // openSubscriptions.remove(roomId) // } // } // roomConsumers.remove(roomId) // }.connect() // ensure members are fetched and presence subscription is opened for each of them // val usersFetchResult = listOf&lt;String&gt;() // //userService.fetchUsersBy(roomStore[roomId]!!.memberUserIds) // if (usersFetchResult is Result.Failure) { // emit(RoomEvent.ErrorOccurred(usersFetchResult.error)) // } // synchronized(buffer) { // buffer.forEach { event -&gt; // consumer(event) // globalConsumer(event) // } // buffer.clear() // ready = true // } // // return proxiedSub } private fun unsubscribeProxy(sub: ChatkitSubscription, hook: (Subscription) -&gt; Unit) = object : ChatkitSubscription { override fun unsubscribe() { hook(sub) sub.unsubscribe() } override fun connect(): Subscription { sub.connect() return this } } fun close() { // synchronized(openSubscriptions) { // openSubscriptions.forEach { (_, sub) -&gt; // sub.unsubscribe() // } // } // roomStore.clear() } private fun translateCursorEvent() {} // (event: ChatEvent): RoomEvent = // when (event) { // is ChatEvent.NewReadCursor -&gt; RoomEvent.NewReadCursor(event.cursor) // else -&gt; RoomEvent.NoEvent // } private fun enrichEvent(event: RoomSubscriptionEvent) {} // : RoomEvent = // when (event) { // is RoomSubscriptionEvent.NewMessage -&gt; RoomEvent.NoEvent // userService.fetchUserBy(event.message.userId).map { user -&gt; // event.message.user = user // RoomEvent.Message(event.message) as RoomEvent // }.recover { // RoomEvent.ErrorOccurred(it) // } // is RoomSubscriptionEvent.NewMultipartMessage -&gt; RoomEvent.NoEvent // upgradeMessageV3( // event.message, // this, // userService, // urlRefresher // ).map { // RoomEvent.MultipartMessage(it) as RoomEvent // }.recover { // RoomEvent.ErrorOccurred(it) // } // is RoomSubscriptionEvent.MessageDeleted -&gt; RoomEvent.NoEvent // RoomEvent.MessageDeleted(event.messageId) // is RoomSubscriptionEvent.UserIsTyping -&gt; RoomEvent.NoEvent // userService.fetchUserBy(event.userId).map { user -&gt; // val onStop = { // consumer(RoomEvent.UserStoppedTyping(user)) // } // // if (scheduleStopTypingEvent(event.userId, onStop)) { // RoomEvent.UserStartedTyping(user) // } else { // RoomEvent.NoEvent // } // }.recover { // RoomEvent.ErrorOccurred(it) // } // is RoomSubscriptionEvent.ErrorOccurred -&gt; // RoomEvent.ErrorOccurred(event.error) // } // Access synchronized on itself private val typingTimers = HashMap&lt;String, Future&lt;Unit&gt;&gt;() private fun scheduleStopTypingEvent(userId: String, onStop: () -&gt; Unit): Boolean { synchronized(typingTimers) { val new = typingTimers[userId] == null if (!new) { typingTimers[userId]!!.cancel() } typingTimers[userId] = Futures.schedule { Thread.sleep(1_500) synchronized(typingTimers) { typingTimers.remove(userId) } onStop() } return new } } // fun distributeGlobalEvent(event: ChatEvent) { // // This function must map events which we wish to report at room scope that // // are not received at room scope from the backend. // // Be careful, if you map an event which originated here, you will create // // an infinite loop consuming that event. // when (event) { // is ChatEvent.RoomUpdated -&gt; // roomConsumers[event.room.id]?.invoke(RoomEvent.RoomUpdated(event.room)) // is ChatEvent.RoomDeleted -&gt; // roomConsumers[event.roomId]?.invoke(RoomEvent.RoomDeleted(event.roomId)) // is ChatEvent.UserJoinedRoom -&gt; // roomConsumers[event.room.id]?.invoke(RoomEvent.UserJoined(event.user)) // is ChatEvent.UserLeftRoom -&gt; // roomConsumers[event.room.id]?.invoke(RoomEvent.UserLeft(event.user)) // is ChatEvent.PresenceChange -&gt; // roomConsumers.keys.forEach { _ -&gt; // if (roomStore[roomId]?.memberUserIds?.contains(event.user.id) == true) { // roomConsumers[roomId]?.invoke( // RoomEvent.PresenceChange(event.user, event.currentState, event.prevState) // ) // } // } // } // } }</ID>
    <ID>TooGenericExceptionCaught:Parser.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RoomSubscriptionEventParser.kt$RoomSubscriptionEventParser$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:SafeCallback.kt$t: Throwable</ID>
    <ID>TooManyFunctions:RoomService.kt$RoomService$RoomService</ID>
    <ID>UnusedPrivateClass:MessageService.kt$MessageService$AttachmentRequest</ID>
    <ID>UnusedPrivateClass:MessageService.kt$MessageService$AttachmentResponse</ID>
  </Whitelist>
</SmellBaseline>
